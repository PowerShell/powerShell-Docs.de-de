---
title: Alles, was Sie schon immer über Ausnahmen wissen wollten
description: Die Fehlerbehandlung gehört beim Schreiben von Code einfach dazu.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 589e5d1decff7aa49ce36e10908e4464a768758d
ms.sourcegitcommit: 1dfd5554b70c7e8f4e3df19e29c384a9c0a4b227
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/03/2021
ms.locfileid: "101685511"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="3c84e-103">Alles, was Sie schon immer über Ausnahmen wissen wollten</span><span class="sxs-lookup"><span data-stu-id="3c84e-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="3c84e-104">Die Fehlerbehandlung gehört beim Schreiben von Code einfach dazu.</span><span class="sxs-lookup"><span data-stu-id="3c84e-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="3c84e-105">Wir können häufig die Bedingungen für erwartetes Verhalten überprüfen und validieren.</span><span class="sxs-lookup"><span data-stu-id="3c84e-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="3c84e-106">Bei unerwartetem Verhalten kommt die Ausnahmebehandlung ins Spiel.</span><span class="sxs-lookup"><span data-stu-id="3c84e-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="3c84e-107">Sie können ganz einfach Ausnahmen behandeln, die durch den Code anderer Programmierer generiert werden, oder Sie können selbst Ausnahmen generieren, die andere behandeln können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="3c84e-108">Die [Originalversion][] dieses Artikels ist im Blog von [@KevinMarquette][] erschienen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="3c84e-109">Das PowerShell-Team dankt Kevin Marquette, dass er diesen Inhalt mit uns teilt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="3c84e-110">Weitere Informationen finden Sie in seinem Blog auf [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="3c84e-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="3c84e-111">Grundlegende Terminologie</span><span class="sxs-lookup"><span data-stu-id="3c84e-111">Basic terminology</span></span>

<span data-ttu-id="3c84e-112">Wir müssen einige grundlegende Begriffe klären, bevor wir uns mit diesem Thema befassen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="3c84e-113">Ausnahme</span><span class="sxs-lookup"><span data-stu-id="3c84e-113">Exception</span></span>

<span data-ttu-id="3c84e-114">Eine Ausnahme ist wie ein Ereignis, das ausgelöst wird, wenn die normale Fehlerbehandlung das Problem nicht beheben kann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="3c84e-115">Der Versuch, eine Zahl durch 0 zu teilen, oder unzureichender Arbeitsspeicher sind Beispiele für Ereignisse, die eine Ausnahme erzeugen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="3c84e-116">Manchmal erstellt der Autor des Codes, den Sie verwenden, Ausnahmen für bestimmte Probleme, falls diese auftreten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="3c84e-117">Throw und Catch</span><span class="sxs-lookup"><span data-stu-id="3c84e-117">Throw and Catch</span></span>

<span data-ttu-id="3c84e-118">Wenn eine Ausnahme auftritt, wird dies als „Auslösen einer Ausnahme“ bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="3c84e-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="3c84e-119">Um eine ausgelöste Ausnahme zu behandeln, müssen Sie sie abfangen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="3c84e-120">Wenn eine Ausnahme ausgelöst und nicht abgefangen wird, wird die Ausführung des Skripts beendet.</span><span class="sxs-lookup"><span data-stu-id="3c84e-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="3c84e-121">Die Aufrufliste</span><span class="sxs-lookup"><span data-stu-id="3c84e-121">The call stack</span></span>

<span data-ttu-id="3c84e-122">Die Aufrufliste ist die Liste der Funktionen, die sich gegenseitig aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="3c84e-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="3c84e-123">Wenn eine Funktion aufgerufen wird, wird sie am Anfang der Liste hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="3c84e-124">Eine Funktion, die beendet oder zurückgegeben wird, wird aus der Liste entfernt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="3c84e-125">Wenn eine Ausnahme ausgelöst wird, wird diese Aufrufliste eingecheckt, damit sie von einem Ausnahmehandler abgefangen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="3c84e-126">Fehler mit und ohne Abbruch</span><span class="sxs-lookup"><span data-stu-id="3c84e-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="3c84e-127">Eine Ausnahme ist im Allgemeinen ein Fehler mit Abbruch.</span><span class="sxs-lookup"><span data-stu-id="3c84e-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="3c84e-128">Eine ausgelöste Ausnahme wird entweder abgefangen oder beendet die aktuelle Ausführung.</span><span class="sxs-lookup"><span data-stu-id="3c84e-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="3c84e-129">Standardmäßig wird ein Fehler ohne Abbruch durch `Write-Error` generiert, und dem Ausgabestream wird ein Fehler hinzugefügt, ohne dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3c84e-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="3c84e-130">Dies sollten Sie unbedingt beachten, da `Write-Error` und andere Fehler ohne Abbruch `catch` nicht auslösen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="3c84e-131">Behalten einer Ausnahme</span><span class="sxs-lookup"><span data-stu-id="3c84e-131">Swallowing an exception</span></span>

<span data-ttu-id="3c84e-132">Dies ist das Verhalten, wenn Sie einen Fehler abfangen, um ihn zu unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="3c84e-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="3c84e-133">Gehen Sie dabei sehr vorsichtig vor, da dies die Problembehandlung sehr schwierig machen kann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="3c84e-134">Grundlegende Befehlssyntax</span><span class="sxs-lookup"><span data-stu-id="3c84e-134">Basic command syntax</span></span>

<span data-ttu-id="3c84e-135">Im Folgenden finden Sie eine kurze Übersicht über die in PowerShell verwendete grundlegende Syntax für die Ausnahmebehandlung.</span><span class="sxs-lookup"><span data-stu-id="3c84e-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="3c84e-136">Throw</span><span class="sxs-lookup"><span data-stu-id="3c84e-136">Throw</span></span>

<span data-ttu-id="3c84e-137">Zum Erstellen unseres eigenen Ausnahmeereignisses lösen wir mit dem Schlüsselwort `throw` eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3c84e-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="3c84e-138">Dadurch wird eine Laufzeitausnahme erstellt, die ein Fehler mit Abbruch ist.</span><span class="sxs-lookup"><span data-stu-id="3c84e-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="3c84e-139">Sie wird von einem `catch` in einer Aufruffunktion verarbeitet oder beendet das Skript mit einer Meldung wie der folgenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="3c84e-140">Write-Error: -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="3c84e-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="3c84e-141">Ich habe bereits erwähnt, dass `Write-Error` nicht standardmäßig einen Fehler mit Abbruch auslöst.</span><span class="sxs-lookup"><span data-stu-id="3c84e-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="3c84e-142">Wenn Sie `-ErrorAction Stop` angeben, generiert `Write-Error` einen Fehler mit Abbruch, der mit einem `catch` behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-142">If you specify `-ErrorAction Stop`, `Write-Error` generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="3c84e-143">Vielen Dank an Lee Dailey, der daran erinnert hat, dass `-ErrorAction Stop` sich auch auf diese Weise verwenden lässt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="3c84e-144">Cmdlet: -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="3c84e-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="3c84e-145">Wenn Sie `-ErrorAction Stop` in einer beliebigen erweiterten Funktion oder einem Cmdlet angeben, werden alle `Write-Error`-Anweisungen in Fehler mit Abbruch umgewandelt, die die Ausführung anhalten oder von einem `catch` verarbeitet werden können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="3c84e-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="3c84e-146">Try/Catch</span></span>

<span data-ttu-id="3c84e-147">Die Ausnahmebehandlung in PowerShell (und vielen anderen Sprachen) funktioniert so, dass Sie zuerst einen `try`-Vorgang für einen Codeabschnitt ausführen. Wenn dadurch ein Fehler ausgelöst wird, können Sie diesen mit `catch` abfangen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="3c84e-148">Im Folgenden sehen Sie ein kurzes Beispiel.</span><span class="sxs-lookup"><span data-stu-id="3c84e-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="3c84e-149">Das `catch`-Skript wird nur ausgeführt, wenn ein Fehler mit Abbruch vorliegt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="3c84e-150">Bei korrekter Ausführung von `try` wird `catch` übersprungen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="3c84e-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="3c84e-151">Try/Finally</span></span>

<span data-ttu-id="3c84e-152">Es gibt Fälle, in denen Sie einen Fehler nicht behandeln müssen, aber dennoch Code benötigen, der ausgeführt wird, wenn eine Ausnahme auftritt oder nicht.</span><span class="sxs-lookup"><span data-stu-id="3c84e-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="3c84e-153">Genau das macht ein `finally`-Skript.</span><span class="sxs-lookup"><span data-stu-id="3c84e-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="3c84e-154">Sehen Sie sich folgendes Beispiel an:</span><span class="sxs-lookup"><span data-stu-id="3c84e-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="3c84e-155">Jedes Mal, wenn Sie eine Verbindung mit einer Ressource herstellen oder öffnen, sollten Sie die Verbindung auch wieder schließen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="3c84e-156">Wenn `ExecuteNonQuery()` eine Ausnahme auslöst, wird die Verbindung nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="3c84e-157">Hier ist derselbe Code in einem `try/finally`-Block.</span><span class="sxs-lookup"><span data-stu-id="3c84e-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="3c84e-158">In diesem Beispiel wird die Verbindung geschlossen, wenn ein Fehler vorliegt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="3c84e-159">Sie wird auch geschlossen, wenn kein Fehler vorliegt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-159">It also is closed if there's no error.</span></span> <span data-ttu-id="3c84e-160">Das `finally`-Skript wird jedes Mal ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="3c84e-161">Da die Ausnahme nicht abgefangen wird, wird sie weiterhin in der Aufrufliste nach oben weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="3c84e-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="3c84e-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="3c84e-162">Try/Catch/Finally</span></span>

<span data-ttu-id="3c84e-163">Es ist völlig zulässig, `catch` und `finally` in Kombination zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="3c84e-164">In den meisten Fällen werden Sie sicher nur eine der Optionen benötigen, aber es kann durchaus Szenarien geben, in denen Sie beide verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="3c84e-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="3c84e-165">$PSItem</span></span>

<span data-ttu-id="3c84e-166">So, die Grundlagen sind bekannt – jetzt können wir etwas genauer ins Detail gehen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="3c84e-167">Innerhalb des `catch`-Blocks gibt es eine automatische Variable (`$PSItem` oder `$_`) vom Typ `ErrorRecord`, die die Details zur Ausnahme enthält.</span><span class="sxs-lookup"><span data-stu-id="3c84e-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="3c84e-168">Im Folgenden sehen Sie eine kurze Übersicht über einige der wichtigsten Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="3c84e-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="3c84e-169">In diesen Beispielen habe ich in `ReadAllText` einen ungültigen Pfad verwendet, um diese Ausnahme zu generieren.</span><span class="sxs-lookup"><span data-stu-id="3c84e-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="3c84e-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="3c84e-170">PSItem.ToString()</span></span>

<span data-ttu-id="3c84e-171">Damit erhalten Sie eine klare und eindeutige Meldung, die Sie bei der Protokollierung und in Ausgaben ganz allgemein verwenden können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="3c84e-172">`ToString()` wird automatisch aufgerufen, wenn `$PSItem` in eine Zeichenfolge eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="3c84e-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="3c84e-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="3c84e-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="3c84e-174">Diese Eigenschaft enthält zusätzliche von PowerShell gesammelte Informationen über die Funktion oder das Skript, in der bzw. dem die Ausnahme ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="3c84e-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="3c84e-175">Hier sehen Sie die `InvocationInfo` aus der Beispielausnahme, die ich erstellt habe.</span><span class="sxs-lookup"><span data-stu-id="3c84e-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="3c84e-176">Die wichtigen Details zeigen hier den `ScriptName`, die `Line` des Codes und die `ScriptLineNumber`, wo der Aufruf begann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="3c84e-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="3c84e-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="3c84e-178">Diese Eigenschaft zeigt die Reihenfolge der Funktionsaufrufe, über die Sie zu dem Code gelangen, in dem die Ausnahme generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="3c84e-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="3c84e-179">Ich führe nur Aufrufe von Funktionen im selben Skript durch, aber hiermit würden die Aufrufe nachverfolgt, wenn mehrere Skripts beteiligt wären.</span><span class="sxs-lookup"><span data-stu-id="3c84e-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="3c84e-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="3c84e-180">$PSItem.Exception</span></span>

<span data-ttu-id="3c84e-181">Dies ist die eigentliche Ausnahme, die ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="3c84e-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="3c84e-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="3c84e-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="3c84e-183">Hier sehen Sie die allgemeine Meldung, in der die Ausnahme beschrieben wird. Diese ist ein guter Ausgangspunkt für die Problembehandlung.</span><span class="sxs-lookup"><span data-stu-id="3c84e-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="3c84e-184">Für die meisten Ausnahmen gibt es eine Standardmeldung, Sie können aber auch benutzerdefinierte Meldungen festlegen, die beim Auslösen einer Ausnahme angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="3c84e-185">Dies ist auch die Meldung, die beim Aufrufen von `$PSItem.ToString()` zurückgegeben wird, wenn nichts im `ErrorRecord` festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="3c84e-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="3c84e-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="3c84e-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="3c84e-187">Ausnahmen können innere Ausnahmen enthalten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="3c84e-188">Dies ist häufig der Fall, wenn der aufgerufene Code eine Ausnahme abfängt und eine andere Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="3c84e-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="3c84e-189">Die ursprüngliche Ausnahme wird in die neue Ausnahme eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="3c84e-190">Ich werde dies später genauer erläutern, wenn es um das erneute Auslösen von Ausnahmen geht.</span><span class="sxs-lookup"><span data-stu-id="3c84e-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="3c84e-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="3c84e-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="3c84e-192">Das ist die `StackTrace` (Stapelüberwachung) für die Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="3c84e-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="3c84e-193">Ich habe oben eine `ScriptStackTrace` gezeigt, aber diese hier ist für die Aufrufe von verwaltetem Code vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="3c84e-194">Sie erhalten diese Stapelüberwachung nur, wenn das Ereignis durch verwalteten Code ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3c84e-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="3c84e-195">Ich rufe direkt eine .NET Framework-Funktion auf. Das ist also alles, was wir in diesem Beispiel sehen können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="3c84e-196">Wenn Sie sich eine Stapelüberwachung ansehen, sollten Sie nach der Stelle suchen, an der Ihr Code aufhört und die Systemaufrufe beginnen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="3c84e-197">Arbeiten mit Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="3c84e-197">Working with exceptions</span></span>

<span data-ttu-id="3c84e-198">Das Thema Ausnahmen umfasst weit mehr als die grundlegende Syntax und Ausnahmeeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="3c84e-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="3c84e-199">Abfangen typisierter Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="3c84e-199">Catching typed exceptions</span></span>

<span data-ttu-id="3c84e-200">Sie können auswählen, welche Ausnahmen Sie abfangen wollen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="3c84e-201">Ausnahmen besitzen einen Typ, und Sie können angeben, welchen Ausnahmetyp Sie abfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="3c84e-202">Der Ausnahmetyp wird für jeden `catch`-Block geprüft, bis ein Typ gefunden wird, der mit der Ausnahme übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="3c84e-203">Sie müssen wissen, dass Ausnahmen von anderen Ausnahmen erben können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="3c84e-204">Im Beispiel oben erbt `FileNotFoundException` von `IOException`.</span><span class="sxs-lookup"><span data-stu-id="3c84e-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="3c84e-205">Wenn also zuerst `IOException` aufgetreten ist, würde diese Ausnahme stattdessen verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="3c84e-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="3c84e-206">Auch bei mehreren Übereinstimmungen wird nur ein catch-Block aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="3c84e-207">Wenn wir beispielsweise eine `System.IO.PathTooLongException` hätten, würde die `IOException` übereinstimmen. Hätten wir aber eine `InsufficientMemoryException`, dann würde diese nicht abgefangen und stattdessen im Stapel nach oben weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="3c84e-208">Gleichzeitiges Abfangen mehrerer Typen</span><span class="sxs-lookup"><span data-stu-id="3c84e-208">Catch multiple types at once</span></span>

<span data-ttu-id="3c84e-209">Es ist möglich, mehrere Ausnahmetypen mit der gleichen `catch`-Anweisung abzufangen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="3c84e-210">Vielen Dank an `/u/Sheppard_Ra` für diesen Vorschlag.</span><span class="sxs-lookup"><span data-stu-id="3c84e-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="3c84e-211">Auslösen typisierter Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="3c84e-211">Throwing typed exceptions</span></span>

<span data-ttu-id="3c84e-212">Sie können in PowerShell typisierte Ausnahmen auslösen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="3c84e-213">Anstatt wie folgt `throw` mit einer Zeichenfolge aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="3c84e-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="3c84e-214">Verwenden Sie stattdessen einen Ausnahmebeschleuniger wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="3c84e-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="3c84e-215">In diesem Fall müssen Sie jedoch eine Meldung angeben.</span><span class="sxs-lookup"><span data-stu-id="3c84e-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="3c84e-216">Sie können auch eine neue Instanz einer Ausnahme erstellen, die ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="3c84e-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="3c84e-217">In diesem Fall ist die Meldung optional, da das System über Standardmeldungen für alle integrierten Ausnahmen verfügt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="3c84e-218">Wenn Sie nicht PowerShell 5.0 oder höher verwenden, müssen Sie den älteren Ansatz `New-Object` verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="3c84e-219">Indem Sie eine typisierte Ausnahme verwenden, können Sie (oder andere) die Ausnahme nach Typ abfangen, wie im vorherigen Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="3c84e-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="3c84e-220">Write-Error: -Exception</span><span class="sxs-lookup"><span data-stu-id="3c84e-220">Write-Error -Exception</span></span>

<span data-ttu-id="3c84e-221">Wir können diese typisierten Ausnahmen zu `Write-Error` hinzufügen und weiterhin einen `catch`-Vorgang für die Fehler nach Ausnahmetyp durchführen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="3c84e-222">Verwenden Sie `Write-Error` wie in diesen Beispielen:</span><span class="sxs-lookup"><span data-stu-id="3c84e-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="3c84e-223">Dann können wir sie wie folgt abfangen:</span><span class="sxs-lookup"><span data-stu-id="3c84e-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="3c84e-224">Die lange Liste der .NET-Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="3c84e-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="3c84e-225">Ich habe mithilfe der [Reddit/r/PowerShell-Community][] eine Masterliste mit Hunderten .NET-Ausnahmen als Ergänzung für diesen Beitrag zusammengestellt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="3c84e-226">[Die lange Liste der .NET-Ausnahmen][]</span><span class="sxs-lookup"><span data-stu-id="3c84e-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="3c84e-227">Ich durchsuche diese Liste zunächst nach Ausnahmen, die meiner Ansicht nach gut zu meiner Situation passen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="3c84e-228">Versuchen Sie, Ausnahmen im Basis-`System`-Namespace zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="3c84e-229">Ausnahmen sind Objekte</span><span class="sxs-lookup"><span data-stu-id="3c84e-229">Exceptions are objects</span></span>

<span data-ttu-id="3c84e-230">Wenn Sie damit anfangen, viele typisierte Ausnahmen zu verwenden, behalten Sie im Hinterkopf, dass es sich um-Objekte handelt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="3c84e-231">Unterschiedliche Ausnahmen besitzen unterschiedliche Konstruktoren und Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="3c84e-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="3c84e-232">Wenn Sie in der [FileNotFoundException][]-Dokumentation nach `System.IO.FileNotFoundException`suchen, sehen Sie, dass Sie eine Meldung und einen Dateipfad übergeben können.</span><span class="sxs-lookup"><span data-stu-id="3c84e-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="3c84e-233">Und es gibt eine `FileName`-Eigenschaft, die diesen Dateipfad verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="3c84e-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="3c84e-234">Weitere Konstruktoren und Objekteigenschaften finden Sie in der [.NET-Dokumentation][].</span><span class="sxs-lookup"><span data-stu-id="3c84e-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="3c84e-235">Erneutes Auslösen einer Ausnahme</span><span class="sxs-lookup"><span data-stu-id="3c84e-235">Re-throwing an exception</span></span>

<span data-ttu-id="3c84e-236">Wenn Sie in Ihrem `catch`-Block lediglich einen `throw`-Vorgang für dieselbe Ausnahme durchführen möchten, dann führen Sie keinen `catch`-Vorgang durch.</span><span class="sxs-lookup"><span data-stu-id="3c84e-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="3c84e-237">Sie sollten nur einen `catch`-Vorgang für eine Ausnahme durchführen, die Sie behandeln oder für die Sie eine Aktion ausführen möchten, wenn sie auftritt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="3c84e-238">Es gibt Fälle, in denen Sie eine Aktion für eine Ausnahme ausführen, die Ausnahme aber erneut auslösen möchten, damit ein nachgeschalteter Prozess sie verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="3c84e-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="3c84e-239">Wir könnten eine Meldung schreiben oder das Problem in der Nähe der Stelle protokollieren, an der wir es entdeckt haben, das Problem aber weiter oben im Stapel verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="3c84e-240">Interessanterweise können wir `throw` innerhalb von `catch` aufrufen, und die aktuelle Ausnahme wird erneut ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3c84e-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="3c84e-241">Wir möchten die Ausnahme erneut auslösen, um die ursprünglichen Ausführungsinformationen wie Quellskript und Zeilennummer beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="3c84e-242">Wenn wir an dieser Stelle eine neue Ausnahme auslösen, wird verborgen, wo die Ausnahme begonnen hat.</span><span class="sxs-lookup"><span data-stu-id="3c84e-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="3c84e-243">Erneutes Auslösen einer neuen Ausnahme</span><span class="sxs-lookup"><span data-stu-id="3c84e-243">Re-throwing a new exception</span></span>

<span data-ttu-id="3c84e-244">Wenn Sie eine Ausnahme abfangen, aber eine andere auslösen möchten, sollten Sie die ursprüngliche Ausnahme in der neuen Ausnahme schachteln.</span><span class="sxs-lookup"><span data-stu-id="3c84e-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="3c84e-245">Dadurch kann weiter unten im Stapel als `$PSItem.Exception.InnerException` darauf zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="3c84e-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="3c84e-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="3c84e-247">Das Einzige, was mir an der Verwendung von `throw` für unformatierte Ausnahmen nicht gefällt, ist die Tatsache, dass die Fehlermeldung auf die `throw`-Anweisung zeigt und angibt, dass sich das Problem in dieser Zeile befindet.</span><span class="sxs-lookup"><span data-stu-id="3c84e-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="3c84e-248">Eine Meldung zu einem Fehler im Skript aufgrund des Aufrufs von `throw` in Zeile 31 ist für die Benutzer Ihres Skripts nicht wirklich brauchbar.</span><span class="sxs-lookup"><span data-stu-id="3c84e-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="3c84e-249">Sie erhalten dadurch keine hilfreichen Informationen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="3c84e-250">Dexter Dhami hat darauf hingewiesen, dass ich `ThrowTerminatingError()` verwenden kann, um dies zu korrigieren.</span><span class="sxs-lookup"><span data-stu-id="3c84e-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="3c84e-251">Wenn wir davon ausgehen, dass `ThrowTerminatingError()` in einer Funktion namens `Get-Resource` aufgerufen wurde, sollten wir den folgenden Fehler sehen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="3c84e-252">Sehen Sie, wie auf die `Get-Resource`-Funktion als Quelle des Problems verwiesen wird?</span><span class="sxs-lookup"><span data-stu-id="3c84e-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="3c84e-253">Das sind hilfreiche Informationen für Benutzer.</span><span class="sxs-lookup"><span data-stu-id="3c84e-253">That tells the user something useful.</span></span>

<span data-ttu-id="3c84e-254">Da `$PSItem` ein `ErrorRecord` ist, können wir auch `ThrowTerminatingError` auf diese Weise zum erneuten Auslösen verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="3c84e-255">Dadurch wird die Fehlerquelle für das Cmdlet geändert, und die Interna Ihrer Funktion werden vor den Benutzern Ihres Cmdlets verborgen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="3c84e-256">„try“ kann Fehler mit Abbruch erstellen</span><span class="sxs-lookup"><span data-stu-id="3c84e-256">Try can create terminating errors</span></span>

<span data-ttu-id="3c84e-257">Kirk Munro weist darauf hin, dass einige Ausnahmen nur bei Ausführung in einem `try/catch`-Block Fehler mit Abbruch sind.</span><span class="sxs-lookup"><span data-stu-id="3c84e-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="3c84e-258">Er hat mir das folgende Beispiel zur Verfügung gestellt, das eine Laufzeitausnahme aufgrund einer Division durch Null generiert.</span><span class="sxs-lookup"><span data-stu-id="3c84e-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="3c84e-259">Führen Sie den Aufruf wie folgt aus. Sie werden sehen, dass der Fehler generiert und die Meldung trotzdem ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3c84e-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="3c84e-260">Wenn Sie jedoch denselben Code in einem `try/catch`-Block einfügen, passiert etwas anderes.</span><span class="sxs-lookup"><span data-stu-id="3c84e-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="3c84e-261">Der Fehler wird zu einem Fehler mit Abbruch, und die erste Meldung wird nicht ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="3c84e-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="3c84e-262">Ein Aspekt gefällt mir hier allerdings nicht: Sie können diesen Code in einer Funktion einsetzen, und er verhält sich anders, wenn jemand `try/catch`verwendet.</span><span class="sxs-lookup"><span data-stu-id="3c84e-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="3c84e-263">Ich selbst hatte damit keine Probleme, aber es ist ein – wenngleich seltener – Fall, den Sie kennen müssen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="3c84e-264">$PSCmdlet.ThrowTerminatingError() in „try/catch“</span><span class="sxs-lookup"><span data-stu-id="3c84e-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="3c84e-265">Eine Besonderheit von `$PSCmdlet.ThrowTerminatingError()` besteht darin, dass ein Fehler mit Abbruch innerhalb Ihres Cmdlets erstellt wird, der jedoch nach Verlassen des Cmdlets in einen Fehler ohne Abbruch umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="3c84e-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="3c84e-266">Dadurch muss der Aufrufer Ihrer Funktion entscheiden, wie der Fehler behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="3c84e-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="3c84e-267">Der Fehler kann mit `-ErrorAction Stop` wieder in einen Fehler mit Abbruch umgewandelt oder in `try{...}catch{...}` aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="3c84e-268">Öffentliche Funktionsvorlagen</span><span class="sxs-lookup"><span data-stu-id="3c84e-268">Public function templates</span></span>

<span data-ttu-id="3c84e-269">Eine letzte Information, die ich aus meinem Gespräch mit Kirk Munro mitgenommen habe: Er platziert einen `try{...}catch{...}`-Block um jeden `begin`-, `process`- und `end`-Block in all seinen erweiterten Funktionen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="3c84e-270">In diesen allgemeinen Catch-Blöcken verwendet er eine einzige Zeile mit `$PSCmdlet.ThrowTerminatingError($PSItem)`, um alle Ausnahmen zu behandeln, die seine Funktionen verlassen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="3c84e-271">Da sich alles in einer `try`-Anweisung innerhalb seiner Funktionen befindet, ist die gesamte Verarbeitung konsistent.</span><span class="sxs-lookup"><span data-stu-id="3c84e-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="3c84e-272">Dadurch erhält der Endbenutzer auch eindeutige Fehler, die den internen Code aus dem generierten Fehler ausblenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="3c84e-273">Trap</span><span class="sxs-lookup"><span data-stu-id="3c84e-273">Trap</span></span>

<span data-ttu-id="3c84e-274">Ich habe mich hier auf den `try/catch`-Aspekt von Ausnahmen konzentriert.</span><span class="sxs-lookup"><span data-stu-id="3c84e-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="3c84e-275">Es gibt jedoch ein älteres Feature, das ich erwähnen muss, bevor wir zum Ende kommen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="3c84e-276">Ein `trap` wird in ein Skript oder eine Funktion platziert, um alle Ausnahmen abzufangen, die in diesem Gültigkeitsbereich auftreten.</span><span class="sxs-lookup"><span data-stu-id="3c84e-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="3c84e-277">Wenn eine Ausnahme auftritt, wird der Code im `trap` ausgeführt, und anschließend wird der normale Code fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3c84e-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="3c84e-278">Wenn mehrere Ausnahmen auftreten, wird das Trap immer wieder aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="3c84e-279">Ich persönlich habe diesen Ansatz nie verwendet, kann aber den Nutzen in Admin- oder Controllerskripts sehen, die jede einzelne Ausnahme protokollieren und dann trotzdem weiter ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="3c84e-280">Abschließende Hinweise</span><span class="sxs-lookup"><span data-stu-id="3c84e-280">Closing remarks</span></span>

<span data-ttu-id="3c84e-281">Mit einer vernünftigen Ausnahmebehandlung werden Ihre Skripts nicht nur stabiler, sondern Sie können Probleme mit diesen Ausnahmen auch einfacher beheben.</span><span class="sxs-lookup"><span data-stu-id="3c84e-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="3c84e-282">Ich habe `throw` sehr ausführlich erläutert, weil es eins der Kernkonzepte der Ausnahmebehandlung ist.</span><span class="sxs-lookup"><span data-stu-id="3c84e-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="3c84e-283">PowerShell bietet auch `Write-Error` zum Verarbeiten aller Situationen, in denen Sie `throw` verwenden würden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="3c84e-284">Denken Sie also nach der Lektüre dieses Artikels nicht, dass Sie `throw` unbedingt verwenden müssen.</span><span class="sxs-lookup"><span data-stu-id="3c84e-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="3c84e-285">Nachdem ich die Ausnahmebehandlung so ausführlich beschrieben habe, werde ich jetzt `Write-Error -Stop` verwenden, um Fehler in meinem Code zu generieren.</span><span class="sxs-lookup"><span data-stu-id="3c84e-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="3c84e-286">Ich werde auch den Rat von Kirk beherzigen und `ThrowTerminatingError` als bevorzugten Ausnahmehandler für jede Funktion verwenden.</span><span class="sxs-lookup"><span data-stu-id="3c84e-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[Originalversion]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell-Community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Die lange Liste der .NET-Ausnahmen]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET-Dokumentation]: /dotnet/api
[.NET documentation]: /dotnet/api
